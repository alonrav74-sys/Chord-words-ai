<!doctype html>
<html lang="he" dir="rtl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ChordFinderPro — v20 Perfect Sync ✅ FIXED</title>
  <meta name="theme-color" content="#0b1022" />
  <style>
    :root{--bg:#0b1022;--panel:#0f172a;--muted:#94a3b8;--text:#e5e7eb;--card:#0a1324;--border:#1b2333;--brand:#22c55e;--accent:#38bdf8;--alert:#f59e0b}
    *{box-sizing:border-box}
    body{margin:0;background:linear-gradient(160deg,var(--bg),#0a0f1c);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;color:var(--text);direction:rtl}
    .wrap{max-width:1200px;margin:auto;padding:18px}
    h1{margin:6px 0 10px;font-size:24px}
    .muted{color:var(--muted);font-size:14px}
    .panel{background:#0c162b;border:1px solid #1f2a40;border-radius:16px;padding:14px;margin-top:12px}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    input[type="file"], select, button, input[type="number"], input[type="text"]{padding:10px 14px;border-radius:12px;border:1px solid #223;background:#0b1221;color:#cfe3ff;appearance:none;font-weight:700;cursor:pointer}
    input[type="text"]{width:100%;max-width:500px;font-weight:400}
    .badge{display:inline-flex;gap:6px;align-items:center;background:#0b1221;border:1px solid #1f2937;color:#cbd5e1;border-radius:999px;padding:6px 10px;font-size:12px}
    .badge.ai{border-color:#23664d;background:#0d2e1f;color:#d7ffe6}
    .badge.pro{border-color:#664d23;background:#2e1f0d;color:#ffd7a3}
    .badge.whisper{border-color:#38bdf8;background:#0a1f2e;color:#bae6fd}
    .live{background:#0c162b;border:1px solid #1f2a40;border-radius:16px;padding:18px;margin-top:10px}
    .live .title{color:#a9b4c8;font-size:13px}
    .live .ch{font-weight:800;font-size:42px}
    .live .func{font-size:14px;color:#38bdf8;margin-top:4px}
    .live .lyric{font-size:18px;color:#cbd5e1;margin-top:12px;font-style:italic;direction:rtl;line-height:1.6;background:#0a1324;padding:10px;border-radius:8px}
    .mono{font-family:'Courier New',monospace;white-space:pre;line-height:1.4;direction:ltr;text-align:left;font-size:14px;letter-spacing:0}
    .pill{display:inline-flex;gap:8px;align-items:center;padding:6px 10px;border-radius:999px;border:1px solid #2a3d55;margin:2px 4px;background:#0b1221}
    .ok{border-color:#1f5f3f;color:#d7ffe6;background:#0d2e1f}
    .err{border-color:#5f2323;color:#ffe0e0;background:#3f1d1d}
    .warn{border-color:#8a6a1f;color:#fff0d9;background:#3a2a0c}
    .spin{width:12px;height:12px;border-radius:50%;border:2px solid var(--accent);border-top-color:transparent;animation:sp 1s linear infinite}
    @keyframes sp{to{transform:rotate(360deg)}}
    .chip{display:inline-flex;align-items:center;gap:6px;padding:2px 8px;border-radius:999px;background:#0b1221;border:1px solid #1f2a40;font-size:12px}
    .chip .dot{width:6px;height:6px;border-radius:50%;background:#22c55e}
    .chip.ornament{border-color:#8a6a1f;background:#2a2010}
    .chip.structural{border-color:#1f5f3f;background:#0d2e1f}
    .sliderRow{display:flex;align-items:center;gap:10px;margin-top:8px}
    input[type="range"]{width:220px}
    .tag{font-size:12px;color:#cbd5e1;border:1px solid #1f2a40;padding:4px 8px;border-radius:999px;background:#0b1221}
    .analysis-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(250px,1fr));gap:12px;margin-top:12px}
    .analysis-card{background:#0b1221;border:1px solid #1f2a40;border-radius:12px;padding:12px}
    .analysis-card h3{margin:0 0 8px 0;font-size:14px;color:#38bdf8}
    .analysis-card .value{font-size:20px;font-weight:700;color:#22c55e}
    .yt-result{display:flex;gap:10px;padding:10px;border:1px solid #1f2a40;border-radius:10px;margin-top:8px;align-items:center;cursor:pointer;transition:all 0.2s}
    .yt-result:hover{background:#12203a;border-color:#38bdf8}
    .yt-result.selected{background:#164e3a;border-color:#22c55e}
    .yt-result img.thumb{width:120px;height:68px;object-fit:cover;border-radius:8px;flex-shrink:0}
    .yt-result .info{flex:1;min-width:0}
    .yt-result .title{font-weight:700;margin-bottom:4px;color:#e5e7eb;word-wrap:break-word;white-space:normal;line-height:1.3}
    .yt-result .channel{font-size:12px;color:#94a3b8}
    .yt-results{max-height:400px;overflow-y:auto}
    .tabs{display:flex;gap:4px;margin-bottom:12px}
    .tab{padding:8px 16px;border-radius:8px;background:#0b1221;border:1px solid #1f2a40;cursor:pointer;transition:all 0.2s}
    .tab.active{background:#0d2e1f;border-color:#22c55e;color:#d7ffe6}
    .tab:hover{border-color:#38bdf8}
    .tab-content{display:none}
    .tab-content.active{display:block}
    .info-box{background:#1f2a40;padding:10px;border-radius:8px;margin-top:8px;font-size:13px;color:#cbd5e1}
    .info-box.success{background:#0d2e1f;border:1px solid #22c55e}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>🎵 Chord Finder Pro — v20 סנכרון מושלם ✅
      <span class="badge pro">Professional</span>
      <span class="badge whisper">Whisper Sync</span>
    </h1>
    <div class="muted">אקורדים ממש מעל המילים - כמו דף נגינה אמיתי</div>

    <section class="panel">
      <div class="tabs">
        <div class="tab active" data-tab="file">📁 קובץ מקומי</div>
        <div class="tab" data-tab="youtube">🎬 יוטיוב</div>
        <div class="tab" data-tab="sheet">📝 דף נגינה</div>
      </div>

      <div id="fileTab" class="tab-content active">
        <div class="row">
          <input id="file" type="file" accept="audio/*,video/*" />
        </div>
      </div>

      <div id="youtubeTab" class="tab-content">
        <div class="info-box success">
          ⚡ <strong>סנכרון מדויק!</strong> אקורדים ממש מעל כל מילה!
        </div>
        
        <div class="row" style="margin-top:12px">
          <input id="ytSearch" type="text" placeholder='חפש שיר (למשל: "Leonard Cohen Hallelujah")' />
          <button id="ytSearchBtn">🔍 חפש</button>
        </div>
        
        <div id="ytResults" class="yt-results" style="display:none"></div>
        
        <div style="margin-top:12px">
          <div style="margin-bottom:8px;font-weight:700">או הדבק קישור יוטיוב:</div>
          <div class="row">
            <input id="ytUrl" type="text" placeholder="https://www.youtube.com/watch?v=..." style="flex:1" />
            <button id="ytUrlBtn">✓ השתמש</button>
          </div>
        </div>
        
        <div id="ytStatus" class="pill" style="display:none;margin-top:8px"></div>
        <div id="whisperStatus" class="pill warn" style="display:none;margin-top:8px">
          <span class="spin"></span> 🎤 Whisper עובד ברקע...
        </div>
      </div>

      <div id="sheetTab" class="tab-content">
        <h3>📋 דף נגינה מקצועי</h3>
        <div id="fullSheet" class="mono" style="max-height:500px;overflow:auto;background:#0b1221;padding:16px;border-radius:8px">—</div>
        
        <h3 style="margin-top:16px">🎤 תמלול מלא</h3>
        <div id="fullTranscript" style="max-height:300px;overflow:auto;background:#0b1221;padding:12px;border-radius:8px;white-space:pre-wrap;font-family:Arial">—</div>
        
        <div class="row" style="margin-top:12px">
          <button id="exportBtn">💾 ייצא ל-ChordPro</button>
          <button id="copyBtn">📋 העתק דף</button>
        </div>
      </div>

      <div class="row" style="margin-top:12px">
        <label>מצב זיהוי:
          <select id="extMode">
            <option value="basic">בסיסי</option>
            <option value="jazz" selected>ג'אז (7/9/11/13)</option>
            <option value="pro">מקצועי</option>
          </select>
        </label>
        <label>קוואנטה:
          <select id="quant">
            <option value="4" selected>1/4</option>
            <option value="8">1/8</option>
          </select>
        </label>
        <label>🎸 קאפו:
          <input id="capo" type="number" value="0" min="0" max="11" style="width:80px" />
        </label>
        <button id="analyzeBtn">נתח</button>
        <button id="playBtn" disabled>🎧 הפעל</button>
      </div>

      <div class="row" style="margin-top:8px">
        <span class="badge">BPM: <b id="bpm">—</b></span>
        <span class="badge">משך: <b id="dur">—</b></span>
        <span class="badge">סולם: <b id="keyBadge">—</b></span>
        <span class="badge">מצב: <b id="modeBadge">—</b></span>
        <span id="aiBadge" class="badge ai" style="display:none">AI Enhanced</span>
      </div>

      <div id="status" class="pill ok" style="display:none"></div>
      <div id="error" class="pill err" style="display:none"></div>

      <div class="sliderRow">
        <span class="tag">×<span id="bassMulTxt">1.25</span></span>
        <input id="bassSens" type="range" min="0.5" max="2.0" step="0.05" value="1.25" />
        <span style="color:#94a3b8;font-size:12px">רגישות בס</span>
      </div>
      <div class="sliderRow">
        <span class="tag">×<span id="decMulTxt">1.00</span></span>
        <input id="decSens" type="range" min="0.5" max="2.0" step="0.05" value="1.00" />
        <span style="color:#94a3b8;font-size:12px">רגישות הרחבות</span>
      </div>

      <div class="row">
        <span id="gateChip" class="chip warn" style="display:none"><span class="dot"></span>מחכה לפריטה...</span>
      </div>
    </section>

    <section class="panel">
      <h2>ניתוח הרמוני מתקדם</h2>
      <div class="analysis-grid">
        <div class="analysis-card">
          <h3>אקורדים מבניים</h3>
          <div class="value" id="structuralCount">—</div>
        </div>
        <div class="analysis-card">
          <h3>קישוטים</h3>
          <div class="value" id="ornamentCount">—</div>
        </div>
        <div class="analysis-card">
          <h3>דומיננט משני</h3>
          <div class="value" id="secDomCount">—</div>
        </div>
        <div class="analysis-card">
          <h3>השאלות מודאליות</h3>
          <div class="value" id="modalBorrowCount">—</div>
        </div>
      </div>
    </section>

    <section class="panel">
      <h2>תצוגה חיה</h2>
      <audio id="player" controls preload="auto" crossorigin="anonymous" style="width:100%"></audio>
      <div class="live">
        <div style="flex:1">
          <div class="title">האקורד כרגע</div>
          <div class="ch" id="liveChord">—</div>
          <div class="func" id="liveFunction">—</div>
          <div class="lyric" id="liveLyric">—</div>
        </div>
        <div style="text-align:left">
          <span id="ornamentChip" class="chip ornament" style="display:none">קישוט</span>
          <span id="structuralChip" class="chip structural" style="display:none">מבני</span>
        </div>
      </div>
    </section>

    <section class="panel">
      <h2>📝 דף נגינה — זמן אמת</h2>
      <div id="liveSheet" class="mono" style="background:#0b1221;padding:12px;border-radius:8px;min-height:200px">—</div>
      <div class="row" style="margin-top:8px">
        <button id="resetSheet">אפס דף</button>
      </div>
    </section>
  </div>

<script type="module">
const SERVER = 'https://youtube-proxy-pied.vercel.app';

let selectedYouTubeVideo = null;
let currentTab = 'file';
let WHISPER_SEGMENTS = [];
let WHISPER_RUNNING = false;

const fileEl=document.getElementById('file');
const analyzeBtn=document.getElementById('analyzeBtn');
const playBtn=document.getElementById('playBtn');
const statusEl=document.getElementById('status');
const errorEl=document.getElementById('error');
const whisperStatusEl=document.getElementById('whisperStatus');
const fullTranscriptEl=document.getElementById('fullTranscript');
const fullSheetEl=document.getElementById('fullSheet');
const gateChip=document.getElementById('gateChip');
const player=document.getElementById('player');
const bpmEl=document.getElementById('bpm');
const durEl=document.getElementById('dur');
const capoEl=document.getElementById('capo');
const keyBadge=document.getElementById('keyBadge');
const modeBadge=document.getElementById('modeBadge');
const liveChordEl=document.getElementById('liveChord');
const liveFunctionEl=document.getElementById('liveFunction');
const liveLyricEl=document.getElementById('liveLyric');
const liveSheetEl=document.getElementById('liveSheet');
const resetSheetBtn=document.getElementById('resetSheet');
const exportBtn=document.getElementById('exportBtn');
const copyBtn=document.getElementById('copyBtn');
const aiBadge=document.getElementById('aiBadge');
const bassSensEl=document.getElementById('bassSens');
const decSensEl=document.getElementById('decSens');
const bassMulTxt=document.getElementById('bassMulTxt');
const decMulTxt=document.getElementById('decMulTxt');
const structuralCountEl=document.getElementById('structuralCount');
const ornamentCountEl=document.getElementById('ornamentCount');
const secDomCountEl=document.getElementById('secDomCount');
const modalBorrowCountEl=document.getElementById('modalBorrowCount');
const ornamentChip=document.getElementById('ornamentChip');
const structuralChip=document.getElementById('structuralChip');
const ytSearchEl=document.getElementById('ytSearch');
const ytSearchBtn=document.getElementById('ytSearchBtn');
const ytResultsEl=document.getElementById('ytResults');
const ytStatusEl=document.getElementById('ytStatus');
const ytUrlEl=document.getElementById('ytUrl');
const ytUrlBtn=document.getElementById('ytUrlBtn');

bassSensEl.oninput=()=>bassMulTxt.textContent=Number(bassSensEl.value).toFixed(2);
decSensEl.oninput=()=>decMulTxt.textContent=Number(decSensEl.value).toFixed(2);

// ===== TABS =====
function initTabs() {
  const tabs = document.querySelectorAll('.tab');
  const tabContents = document.querySelectorAll('.tab-content');
  tabs.forEach(tab => {
    tab.addEventListener('click', function() {
      const tabName = this.getAttribute('data-tab');
      currentTab = tabName;
      tabs.forEach(t => t.classList.remove('active'));
      this.classList.add('active');
      tabContents.forEach(content => content.classList.remove('active'));
      const targetContent = document.getElementById(tabName + 'Tab');
      if(targetContent) targetContent.classList.add('active');
      if(tabName === 'sheet') refreshSheetTabView();
    });
  });
}
initTabs();

// ===== WHISPER AI =====
async function runWhisperInBackground() {
  if(WHISPER_RUNNING) return;
  if(!window.__AUDIO_BLOB) {
    console.warn('⚠️ No audio blob available');
    return;
  }
  
  WHISPER_RUNNING = true;
  whisperStatusEl.style.display = 'inline-flex';
  
  console.log('🎤 Starting Whisper');
  console.log('📦 Blob size:', window.__AUDIO_BLOB.size, 'bytes');
  
  try {
    // Convert blob to base64
    console.log('🔄 Converting to base64...');
    const reader = new FileReader();
    const base64Promise = new Promise((resolve, reject) => {
      reader.onload = () => resolve(reader.result);
      reader.onerror = reject;
      reader.readAsDataURL(window.__AUDIO_BLOB);
    });
    
    const base64Audio = await base64Promise;
    console.log('✅ Converted, length:', base64Audio.length);
    
    // Send to server (server forwards to Replica)
    console.log('📤 Uploading to server...');
    
    const r = await fetch(`${SERVER}/api/whisper-upload`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ audio: base64Audio })
    });
    
    console.log('📡 Response status:', r.status);
    
    if(!r.ok) {
      const errorText = await r.text();
      console.error('❌ Server error:', errorText);
      throw new Error(`Upload failed: ${r.status}`);
    }
    
    const data = await r.json();
    console.log('📦 [WHISPER] Response:', data);
    
    if(data.success) {
      let segments = [];
      if(data.segments && Array.isArray(data.segments)) {
        segments = data.segments.map(seg => ({
          text: seg.text || '',
          start: seg.start || 0,
          end: seg.end || 0
        })).filter(s => s.text.trim());
      }
      
      if(segments.length > 0) {
        const hasTimestamps = segments.some(s => s.start > 0 || s.end > 0);
        
        if(hasTimestamps) {
          WHISPER_SEGMENTS = segments;
          console.log('✅ Got', segments.length, 'segments WITH timestamps');
          console.log('Sample:', segments[0]);
          
          whisperStatusEl.innerHTML = `✅ Whisper: ${segments.length} קטעים!`;
          whisperStatusEl.className = 'pill ok';
          displayWhisperResult();
          
          setTimeout(() => {
            if(window.__STATE) refreshSheetTabView();
          }, 1000);
        } else {
          console.warn('⚠️ Whisper returned segments but WITHOUT timestamps!');
          
          WHISPER_SEGMENTS = [];
          const fullText = segments.map(s => s.text).join(' ');
          fullTranscriptEl.textContent = '🎤 [Whisper AI - ללא timestamps]\n\n' + fullText;
          
          whisperStatusEl.innerHTML = '⚠️ Whisper (ללא timestamps)';
          whisperStatusEl.className = 'pill warn';
          
          setTimeout(() => {
            if(window.__STATE) refreshSheetTabView();
          }, 1000);
        }
      } else if(data.text && data.text.trim()) {
        console.warn('⚠️ Got text without segments');
        WHISPER_SEGMENTS = [];
        fullTranscriptEl.textContent = '🎤 [Whisper AI]\n\n' + data.text.trim();
        whisperStatusEl.innerHTML = '⚠️ Whisper (רק טקסט)';
        whisperStatusEl.className = 'pill warn';
      } else {
        throw new Error('No transcription in result');
      }
    } else {
      throw new Error(data.error || 'Whisper API failed');
    }
  } catch(e) {
    console.error('💥 Whisper error:', e);
    console.error('💥 Error stack:', e.stack);
    WHISPER_SEGMENTS = [];
    fullTranscriptEl.textContent = '💬 תמלול לא זמין\n\nשגיאה: ' + e.message + '\n\n(בדוק Console לפרטים)';
    whisperStatusEl.innerHTML = '❌ תמלול נכשל - ' + (e.message || 'שגיאה לא ידועה');
    whisperStatusEl.className = 'pill err';
    setTimeout(() => whisperStatusEl.style.display = 'none', 8000);
  } finally {
    WHISPER_RUNNING = false;
  }
}

function displayWhisperResult() {
  if(!WHISPER_SEGMENTS || WHISPER_SEGMENTS.length === 0) {
    fullTranscriptEl.textContent = '💬 תמלול לא זמין';
    return;
  }
  
  const hasTimestamps = WHISPER_SEGMENTS.some(s => (s.start > 0 || s.end > 0));
  
  if(!hasTimestamps) {
    console.warn('⚠️ [DISPLAY] Whisper segments have NO timestamps - all are 0');
    fullTranscriptEl.textContent = '🎤 [Whisper AI - ללא timestamps]\n\n' + 
                                   WHISPER_SEGMENTS.map(s => s.text).join(' ');
    
    WHISPER_SEGMENTS = [];
    return;
  }
  
  const fullText = WHISPER_SEGMENTS.map(s => s.text || '').join(' ').trim();
  fullTranscriptEl.textContent = '🎤 [Whisper AI - עם timestamps]\n\n' + fullText;
  
  console.log('✅ [DISPLAY] Showing transcript with', WHISPER_SEGMENTS.length, 'segments');
}

// ===== YOUTUBE SEARCH =====
ytSearchBtn.onclick = async () => {
  const query = ytSearchEl.value.trim();
  if (!query) return showYtStatus('הזן שם שיר', 'warn');
  showYtStatus('מחפש...', 'warn');
  ytResultsEl.style.display = 'none';
  try {
    const r = await fetch(`${SERVER}/api/yt?q=${encodeURIComponent(query)}`);
    const data = await r.json();
    if (!data || !data.length) return showYtStatus('לא נמצא', 'warn');
    displayYouTubeResults(data.map(v => ({
      videoId: v.id, title: v.title, author: v.author || v.channel, thumbnail: v.thumbnail
    })));
    ytStatusEl.style.display = 'none';
    ytResultsEl.style.display = 'block';
  } catch (e) {
    showYtStatus('שגיאה בחיפוש', 'err');
  }
};
ytSearchEl.onkeydown = (e) => { if(e.key === 'Enter') ytSearchBtn.click(); };

ytUrlBtn.onclick = async () => {
  const url = ytUrlEl.value.trim();
  if(!url) return showYtStatus('הזן קישור', 'warn');
  const videoId = extractYouTubeId(url);
  if(!videoId) return showYtStatus('קישור לא תקין', 'err');
  selectedYouTubeVideo = { id: videoId, title: 'YouTube Video', url: `https://www.youtube.com/watch?v=${videoId}` };
  showYtStatus('✓ נבחר', 'ok');
  ytResultsEl.style.display = 'none';
};

function extractYouTubeId(url) {
  const patterns = [
    /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([a-zA-Z0-9_-]{11})/,
    /^([a-zA-Z0-9_-]{11})$/
  ];
  for(const pattern of patterns) {
    const match = url.match(pattern);
    if(match) return match[1];
  }
  return null;
}

function showYtStatus(msg, type) {
  ytStatusEl.textContent = msg;
  ytStatusEl.className = `pill ${type}`;
  ytStatusEl.style.display = 'inline-flex';
}

function displayYouTubeResults(results) {
  ytResultsEl.innerHTML = '';
  results.forEach((video) => {
    if(!video.videoId) return;
    const div = document.createElement('div');
    div.className = 'yt-result';
    div.innerHTML = `
      <img class="thumb" src="${video.thumbnail}" alt="" onerror="this.src='data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 120 68%22%3E%3Crect fill=%22%231f2937%22 width=%22120%22 height=%2268%22/%3E%3C/svg%3E'" />
      <div class="info">
        <div class="title">${escapeHtml(video.title || 'Unknown')}</div>
        <div class="channel">${escapeHtml(video.author || 'Unknown')}</div>
      </div>
    `;
    div.onclick = async () => {
      document.querySelectorAll('.yt-result').forEach(r => r.classList.remove('selected'));
      div.classList.add('selected');
      selectedYouTubeVideo = { id: video.videoId, title: video.title, url: `https://www.youtube.com/watch?v=${video.videoId}` };
      ytUrlEl.value = selectedYouTubeVideo.url;
      showYtStatus('✓ נבחר', 'ok');
    };
    ytResultsEl.appendChild(div);
  });
}

function escapeHtml(text) { 
  const div = document.createElement('div'); 
  div.textContent = text; 
  return div.innerHTML; 
}

// ===== STATUS =====
function showAnalyzing(stepText){ 
  statusEl.innerHTML='<span class="spin"></span> '+stepText; 
  statusEl.className='pill warn'; 
  statusEl.style.display='inline-flex'; 
}
function ok(msg){ 
  statusEl.textContent=msg; 
  statusEl.className='pill ok'; 
  statusEl.style.display='inline-flex'; 
}
function err(msg){ 
  errorEl.textContent=msg; 
  errorEl.style.display='inline-flex'; 
}
function hideAlerts(){ 
  statusEl.style.display='none'; 
  errorEl.style.display='none'; 
  gateChip.style.display='none'; 
}

// ===== MUSICAL CONSTANTS =====
const NOTES_SHARP=['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
const NOTES_FLAT=['C','Db','D','Eb','E','F','Gb','G','Ab','A','Bb','B'];
const MAJOR_SCALE=[0,2,4,5,7,9,11];
const MINOR_SCALE=[0,2,3,5,7,8,10];
const KS_MAJOR=[6.35,2.23,3.48,2.33,4.38,4.09,2.52,5.19,2.39,3.66,2.29,2.88];
const KS_MINOR=[6.33,2.68,3.52,5.38,2.60,3.53,2.54,4.75,3.98,2.69,3.34,3.17];

const toPc=n=>((n%12)+12)%12;
const nameSharp=i=>NOTES_SHARP[toPc(i)];
const nameFlat=i=>NOTES_FLAT[toPc(i)];

function parseRoot(label){ 
  const m=label?.match?.(/^([A-G](?:#|b)?)/); 
  if(!m) return -1; 
  const nm=m[1].replace('b','#'); 
  return NOTES_SHARP.indexOf(nm); 
}

function applyCapoToLabel(label, capo){
  if(!capo || capo===0) return label;
  const m=label.match(/^([A-G](?:#|b)?)(.*)$/); 
  if(!m) return label;
  const idx=NOTES_SHARP.indexOf(m[1].replace('b','#')); 
  if(idx<0) return label;
  return nameFlat(toPc(idx - capo))+(m[2]||'');
}

function sanitizeLabel(lbl){ 
  if(!lbl) return lbl; 
  return lbl.replace(/[^A-Ga-g#bm79sus246()/\s+altdim]/g,'').trim(); 
}

function ksScore(chromaAgg, root, isMinor){ 
  const prof=(isMinor? KS_MINOR: KS_MAJOR); 
  let s=0; 
  for(let i=0;i<12;i++) s += chromaAgg[toPc(i+root)] * prof[i]; 
  return s; 
}

// ===== ANALYZE =====
analyzeBtn.onclick=async()=>{
  hideAlerts(); 
  aiBadge.style.display='none';
  liveChordEl.textContent='—'; 
  liveFunctionEl.textContent='—'; 
  liveLyricEl.textContent='—';
  liveSheetEl.textContent='—';
  playBtn.disabled=true; 
  keyBadge.textContent='—'; 
  modeBadge.textContent='—';
  structuralCountEl.textContent='—'; 
  ornamentCountEl.textContent='—'; 
  secDomCountEl.textContent='—'; 
  modalBorrowCountEl.textContent='—';
  
  WHISPER_SEGMENTS = [];
  fullTranscriptEl.textContent = '⏳ ממתין...';

  let audioSource = null;
  if(currentTab === 'file') {
    const f=fileEl.files?.[0]; 
    if(!f){ err('בחר קובץ'); return; }
    audioSource = { type: 'file', data: f };
  } else {
    if(!selectedYouTubeVideo) { err('בחר סרטון'); return; }
    audioSource = { type: 'youtube', data: selectedYouTubeVideo };
  }

  try{
    showAnalyzing('שלב 1/6: טעינת אודיו');
    const st1 = await decodeAudio(audioSource);
    
    bpmEl.textContent = st1.bpm; 
    durEl.textContent = st1.duration.toFixed(1)+'s';
    if(st1.url) player.src = st1.url;

    showAnalyzing('שלב 2/6: מיצוי תכונות');
    const feats = extractFeatures(st1);

    showAnalyzing('שלב 3/6: זיהוי סולם');
    const key = estimateKeyKrumhansl(feats);
    const mode = detectMode(feats, key);

    showAnalyzing('שלב 4/6: בנייה מבוססת בס');
    let timeline = buildChordsFromBass(feats, key, st1.bpm);
    
    if(timeline.length === 0 || (timeline.length < 3 && st1.duration > 30)){
      const tonicLabel = nameSharp(key.root) + (key.minor ? 'm' : '');
      timeline.unshift({
        t: 0,
        label: tonicLabel,
        fi: 0,
        endFrame: Math.min(10, feats.chroma.length),
        avgChroma: feats.chroma[0] || new Float32Array(12),
        ornamentType: 'structural'
      });
    }

    showAnalyzing('שלב 5/6: הרחבות');
    const extMode = document.getElementById('extMode').value;
    timeline = decorateQualitiesBassFirst(timeline, feats, key, extMode);
    timeline = addInversionsIfNeeded(timeline, feats);
    
    showAnalyzing('שלב 6/6: קוונטיזציה');
    timeline = validateChords(timeline, key, feats);
    timeline = classifyOrnamentsByDuration(timeline, st1.bpm);
    timeline = quantizeToGrid(timeline, st1.bpm);
    timeline = removeRedundantChords(timeline, st1.bpm);
    
    timeline = timeline.map(ev => ({ 
      ...ev, 
      label: sanitizeLabel(ev.label) 
    }));

    const capo=parseInt(capoEl.value||'0',10);
    keyBadge.textContent = applyCapoToLabel(nameSharp(key.root)+(key.minor?'m':''), capo);
    modeBadge.textContent = mode;

    const structural = timeline.filter(e=>e.ornamentType==='structural').length;
    const ornaments = timeline.filter(e=>e.ornamentType!=='structural').length;
    
    let secDom = 0;
    for(let i=0; i<timeline.length-1; i++){
      if(timeline[i].label.includes('7') && !timeline[i].label.includes('maj7')){
        const rootI = parseRoot(timeline[i].label);
        const rootNext = parseRoot(timeline[i+1].label);
        if(rootI>=0 && rootNext>=0){
          const interval = toPc(rootNext - rootI);
          if(interval === 5 || interval === 7) secDom++;
        }
      }
    }
    
    const diatonic = (key.minor? MINOR_SCALE: MAJOR_SCALE).map(s=>toPc(key.root+s));
    let modalBorrow = 0;
    for(const ev of timeline){
      const r = parseRoot(ev.label);
      if(r>=0 && !diatonic.includes(r)) modalBorrow++;
    }
    
    structuralCountEl.textContent = structural;
    ornamentCountEl.textContent = ornaments;
    secDomCountEl.textContent = secDom;
    modalBorrowCountEl.textContent = modalBorrow;

    window.__STATE = { 
      bpm: st1.bpm, 
      duration: st1.duration, 
      timeline: timeline, 
      key, 
      mode,
      gateTime:detectStartGate(feats)*(feats.hop/feats.sr), 
      feats:{hop:feats.hop,sr:feats.sr} 
    };

    ok('✓ ניתוח הושלם');
    hookPlaybackLive(); 
    refreshSheetTabView();
    playBtn.disabled=false; 
    aiBadge.style.display='inline-flex';
    
    // ⭐ Start Whisper (uses saved blob)
    if(currentTab === 'youtube' && window.__AUDIO_BLOB) {
      runWhisperInBackground();
    }
  }catch(e){ 
    console.error(e); 
    err('שגיאה: '+e.message); 
  }
};

playBtn.onclick=async()=>{ 
  try{ await player.play(); } 
  catch(e){ alert('לחץ ▶️'); } 
};

async function decodeAudio(source){
  if(source.type === 'file') return await decodeAudioFile(source.data);
  else return await decodeYouTubeAudio(source.data);
}

async function decodeAudioFile(file){
  const AC = window.AudioContext || window.webkitAudioContext;
  const ctx = new AC(); 
  try{ await ctx.resume(); }catch{}
  const arr = await file.arrayBuffer();
  
  try{
    const buf = await ctx.decodeAudioData(arr.slice(0));
    return postDecode(buf, URL.createObjectURL(file));
  }catch(e1){
    try{
      const buf = await new Promise((resolve,reject)=>{ 
        ctx.decodeAudioData(arr.slice(0), b=>resolve(b), err=>reject(err)); 
      });
      return postDecode(buf, URL.createObjectURL(file));
    }catch(e2){ throw e2||e1; }
  }
  
  function postDecode(buf, url){
    const mono = (buf.numberOfChannels===1)? buf.getChannelData(0) : mixStereo(buf);
    const sr0=buf.sampleRate, sr=22050;
    const x = resampleLinear(mono, sr0, sr);
    const bpm = estimateTempo(x, sr);
    return { x, sr, bpm, duration: x.length/sr, url };
  }
}

async function decodeYouTubeAudio(video){
  showAnalyzing('מוריד שמע מיוטיוב...');
  try {
    const r = await fetch(`${SERVER}/api/rapidapi-audio?videoId=${video.id}`);
    const data = await r.json();
    if (!data.success || !data.audioUrl) throw new Error('לא נמצא קובץ שמע');
    
    showAnalyzing('מוריד אודיו...');
    const audioRes = await fetch(data.audioUrl);
    const audioBlob = await audioRes.blob();
    
    // ⭐ Save for Whisper!
    window.__AUDIO_BLOB = audioBlob;
    
    const file = new File([audioBlob], 'audio.mp3', { type: 'audio/mpeg' });
    
    return await decodeAudioFile(file);
  } catch (err) {
    throw new Error('לא הצלחתי להוריד');
  }
}

function estimateTempo(x, sr){
  const hop=Math.floor(0.1*sr), frames=[];
  for(let s=0; s+4096<=x.length; s+=hop){ 
    let e=0; 
    for(let i=0;i<4096;i++) e+=x[s+i]*x[s+i]; 
    frames.push(e); 
  }
  const minLag=Math.floor(0.3/(hop/sr)), maxLag=Math.floor(2.0/(hop/sr));
  let bestLag=minLag, bestR=-Infinity;
  for(let lag=minLag; lag<=maxLag; lag++){
    let r=0; 
    for(let i=0;i<frames.length-lag;i++) r += frames[i]*frames[i+lag];
    if(r>bestR){ bestR=r; bestLag=lag; }
  }
  const bpm = 60/(bestLag*(hop/sr));
  return Math.max(60, Math.min(200, Math.round(bpm)));
}

function extractFeatures(st1){
  const {x,sr} = st1, hop=Math.floor(0.10*sr), win=4096;
  const hann=new Float32Array(win); 
  for(let i=0;i<win;i++) hann[i]=0.5*(1-Math.cos(2*Math.PI*i/(win-1)));
  const frames=[]; 
  for(let s=0; s+win<=x.length; s+=hop) frames.push(x.subarray(s,s+win));
  
  function fft(input){ 
    let n=input.length,N=1; 
    while(N<n)N<<=1; 
    const re=new Float32Array(N),im=new Float32Array(N); 
    re.set(input);
    let j=0; 
    for(let i=0;i<N;i++){ 
      if(i<j){ 
        [re[i],re[j]]=[re[j],re[i]]; 
        [im[i],im[j]]=[im[j],im[i]]; 
      } 
      let m=N>>1; 
      while(m>=1&&j>=m){ j-=m; m>>=1; } 
      j+=m; 
    }
    for(let len=2; len<=N; len<<=1){ 
      const ang=-2*Math.PI/len, wlr=Math.cos(ang), wli=Math.sin(ang);
      for(let i=0;i<N;i+=len){ 
        let wr=1, wi=0;
        for(let k=0;k<(len>>1);k++){ 
          const ur=re[i+k], ui=im[i+k];
          const vr=re[i+k+(len>>1)]*wr - im[i+k+(len>>1)]*wi;
          const vi=re[i+k+(len>>1)]*wi + im[i+k+(len>>1)]*wr;
          re[i+k]=ur+vr; im[i+k]=ui+vi;
          re[i+k+(len>>1)]=ur-vr; im[i+k+(len>>1)]=ui-vi;
          const nwr=wr*wlr - wi*wli; wi=wr*wli + wi*wlr; wr=nwr;
        }
      }
    }
    const mags=new Float32Array(N>>1); 
    for(let k=0;k<mags.length;k++) mags[k]=Math.hypot(re[k],im[k]); 
    return {mags,N};
  }
  
  const hz=(b,N)=>b*sr/N; 
  const chroma=[], bassPc=[], bassEnergy=[], frameE=[];
  
  const bpm = st1.bpm || 120;
  const arpeggioWindow = Math.max(4, Math.min(8, Math.round(60 / bpm * sr / hop)));
  
  for(let i=0;i<frames.length;i++){
    const y=new Float32Array(win); 
    for(let k=0;k<win;k++) y[k]=frames[i][k]*hann[k];
    let en=0; 
    for(let k=0;k<win;k++) en += y[k]*y[k]; 
    frameE.push(en);
    
    const accumulated=new Float32Array(12);
    const startIdx = Math.max(0, i - arpeggioWindow + 1);
    
    for(let j=startIdx; j<=i; j++){
      const frame = frames[j];
      const tempY=new Float32Array(win); 
      for(let k=0;k<win;k++) tempY[k]=frame[k]*hann[k];
      const {mags,N}=fft(tempY);
      
      const weight = Math.pow(0.7, i - j);
      
      for(let b=1;b<mags.length;b++){
        const f=hz(b,N); 
        if(f<80||f>5000) continue;
        const midi=69+12*Math.log2(f/440); 
        const pc=toPc(Math.round(midi));
        const freqWeight = f < 300 ? 2.5 : 1.0;
        accumulated[pc] += mags[b] * freqWeight * weight;
      }
    }
    
    let s=0; 
    for(let k=0;k<12;k++) s+=accumulated[k];
    if(s>0){ for(let k=0;k<12;k++) accumulated[k]/=s; }
    chroma.push(accumulated);
    
    const bassChroma = new Float32Array(12); 
    let bassEn = 0;
    
    for(let j=startIdx; j<=i; j++){
      const frame = frames[j];
      const tempY=new Float32Array(win); 
      for(let k=0;k<win;k++) tempY[k]=frame[k]*hann[k];
      const {mags,N}=fft(tempY);
      const weight = Math.pow(0.8, i - j);
      
      for(let b=1;b<mags.length;b++){
        const f=hz(b,N); 
        if(f>=50 && f<=200){
          const midi=69+12*Math.log2(f/440); 
          const pc=toPc(Math.round(midi));
          const fundamental = f < 100 ? 10.0 : (f < 150 ? 5.0 : 2.0);
          bassChroma[pc] += mags[b] * fundamental * weight * 1.8;
          bassEn += mags[b] * weight;
        }
      }
    }
    
    let maxBass = -1, maxVal = 0;
    for(let pc=0; pc<12; pc++){ 
      const score = bassChroma[pc]; 
      if(score > maxVal){ maxVal = score; maxBass = pc; } 
    }
    const threshold = bassEn * 0.20;
    bassPc.push(bassChroma[maxBass] > threshold ? maxBass : -1);
    bassEnergy.push(bassEn);
  }
  
  const thrE = percentileLocal(frameE, 15);
  const bassPcFinal = new Array(bassPc.length).fill(-1);
  for(let i=3;i<bassPc.length-3;i++){
    const v=bassPc[i];
    if(v<0 || frameE[i]<thrE || bassEnergy[i] < percentileLocal(bassEnergy, 10)) continue;
    const window = [bassPc[i-3], bassPc[i-2], bassPc[i-1], v, bassPc[i+1], bassPc[i+2], bassPc[i+3]];
    const votes = window.filter(x => x === v).length;
    if(votes >= 3) bassPcFinal[i] = v;
  }
  return { chroma, bassPc: bassPcFinal, frameE, hop, sr };
}

function estimateKeyKrumhansl(feats){
  const {chroma}=feats, agg=new Array(12).fill(0);
  for(let i=0;i<chroma.length;i++) for(let p=0;p<12;p++) agg[p]+=chroma[i][p];
  const s=agg.reduce((a,b)=>a+b,0)||1; 
  for(let p=0;p<12;p++) agg[p]/=s;
  let best={score:-1, root:0, minor:false};
  for(let r=0;r<12;r++){
    const sMaj=ksScore(agg,r,false), sMin=ksScore(agg,r,true);
    if(sMaj>best.score) best={score:sMaj, root:r, minor:false};
    if(sMin>best.score) best={score:sMin, root:r, minor:true};
  }
  return {root:best.root, minor:best.minor};
}

function detectMode(feats, key){
  const {chroma} = feats, agg = new Array(12).fill(0);
  for(const c of chroma) for(let p=0;p<12;p++) agg[p]+=c[p];
  const s = agg.reduce((a,b)=>a+b,0)||1; 
  for(let p=0;p<12;p++) agg[p]/=s;
  if(!key.minor){
    if(agg[toPc(key.root+10)] > 0.15) return 'Mixolydian';
    if(agg[toPc(key.root+6)] > 0.12) return 'Lydian';
    return 'Major';
  }else{
    if(agg[toPc(key.root+9)] > 0.15 && agg[toPc(key.root+11)] < 0.08) return 'Dorian';
    if(agg[toPc(key.root+11)] > 0.15) return 'Harmonic Minor';
    return 'Natural Minor';
  }
}

function buildChordsFromBass(feats, key, bpm){
  const {bassPc, chroma, frameE, hop, sr} = feats;
  const diatonic = (key.minor? MINOR_SCALE: MAJOR_SCALE).map(s=>toPc(key.root+s));
  const borrowedPcs = key.minor ? [toPc(key.root+8), toPc(key.root+10)] : [];
  const allowedPcs = [...diatonic, ...borrowedPcs];
  
  const spb = 60/Math.max(60, bpm||120);
  const minFrames = Math.max(2, Math.floor((spb * 0.3) / (hop/sr)));
  
  const timeline = [];
  let i = 0;
  
  while(i < bassPc.length){
    if(bassPc[i] < 0 || frameE[i] < percentileLocal(frameE, 15)){
      i++;
      continue;
    }
    
    const root = bassPc[i];
    const startFrame = i;
    const startTime = i * (hop/sr);
    
    if(!allowedPcs.includes(root)){
      i++;
      continue;
    }
    
    let endFrame = startFrame;
    let gapCounter = 0;
    const maxGap = 3;
    
    while(endFrame < bassPc.length){
      if(bassPc[endFrame] === root){
        gapCounter = 0;
        endFrame++;
      } else if(bassPc[endFrame] < 0 || gapCounter < maxGap){
        gapCounter++;
        endFrame++;
      } else {
        break;
      }
    }
    
    if((endFrame - startFrame) < minFrames){
      i = endFrame;
      continue;
    }
    
    const avgChroma = new Float32Array(12);
    let totalWeight = 0;
    
    for(let j=startFrame; j<endFrame; j++){
      if(chroma[j]){
        const weight = Math.sqrt(frameE[j] || 1);
        for(let p=0; p<12; p++) avgChroma[p] += chroma[j][p] * weight;
        totalWeight += weight;
      }
    }
    
    if(totalWeight > 0){
      for(let p=0; p<12; p++) avgChroma[p] /= totalWeight;
    }
    
    const isMinor = decideMajorMinorFromChroma(root, avgChroma);
    let label = nameSharp(root) + (isMinor ? 'm' : '');
    
    timeline.push({
      t: startTime,
      label: label,
      fi: startFrame,
      endFrame: endFrame,
      avgChroma: avgChroma
    });
    
    i = endFrame;
  }
  
  return timeline;
}

function decideMajorMinorFromChroma(root, avgChroma){
  const minor3rd = avgChroma[toPc(root + 3)] || 0;
  const major3rd = avgChroma[toPc(root + 4)] || 0;
  
  if(major3rd > minor3rd * 1.3) return false;
  if(minor3rd > major3rd * 1.3) return true;
  
  return minor3rd >= major3rd * 0.85;
}

function decorateQualitiesBassFirst(tl, feats, key, mode){
  if(mode === 'basic') return tl;
  
  const decMul = Number(decSensEl.value) || 1.0;
  const out = [];
  
  for(const ev of tl){
    const root = parseRoot(ev.label);
    if(root < 0){ out.push(ev); continue; }
    
    const avg = ev.avgChroma;
    let label = ev.label;
    
    const seventh = avg[toPc(root + 10)] || 0;
    const maj7 = avg[toPc(root + 11)] || 0;
    const ninth = avg[toPc(root + 2)] || 0;
    
    const threshold7 = 0.15 / decMul;
    const threshold9 = 0.12 / decMul;
    
    if(mode === 'jazz' || mode === 'pro'){
      if(seventh > threshold7 && seventh > maj7 * 1.2 && !/7/.test(label)){
        label += '7';
      } else if(maj7 > threshold7 && maj7 > seventh * 1.2 && !/7/.test(label)){
        label += 'maj7';
      }
      
      if(mode === 'pro' && /7/.test(label) && ninth > threshold9){
        label = label.replace('7', '9');
        label = label.replace('maj7', 'maj9');
      }
    }
    
    out.push({...ev, label});
  }
  
  return out;
}

function addInversionsIfNeeded(tl, feats){
  const bassSens = Number(bassSensEl.value) || 1.25;
  if(bassSens < 1.6) return tl;
  
  return tl.map(ev => {
    const root = parseRoot(ev.label);
    if(root < 0) return ev;
    
    const {bassPc} = feats;
    const i0 = Math.max(0, ev.fi);
    const i1 = Math.min(bassPc.length-1, ev.endFrame || ev.fi+3);
    
    const bassVotes = new Array(12).fill(0);
    for(let i=i0; i<=i1; i++){
      if(bassPc[i] >= 0) bassVotes[bassPc[i]]++;
    }
    
    const dominantBass = bassVotes.indexOf(Math.max(...bassVotes));
    if(dominantBass < 0 || dominantBass === root) return ev;
    
    const intervals = [0, 3, 4, 7, 10, 11];
    const bassInterval = toPc(dominantBass - root);
    
    if(intervals.includes(bassInterval)){
      const bassNote = nameSharp(dominantBass);
      return {...ev, label: ev.label + '/' + bassNote};
    }
    
    return ev;
  });
}

function validateChords(tl, key, feats){
  const diatonic = (key.minor? MINOR_SCALE: MAJOR_SCALE).map(s=>toPc(key.root+s));
  
  return tl.filter(ev => {
    const root = parseRoot(ev.label);
    if(root < 0) return false;
    
    const isInKey = diatonic.includes(root);
    if(isInKey) return true;
    
    const chromaStrength = ev.avgChroma ? ev.avgChroma[root] : 0;
    return chromaStrength >= 0.25;
  });
}

function classifyOrnamentsByDuration(tl, bpm){
  const spb = 60 / Math.max(60, bpm || 120);
  const structuralThreshold = spb * 1.5;
  
  return tl.map((ev, i) => {
    const nextEv = tl[i+1];
    const duration = nextEv ? (nextEv.t - ev.t) : (spb * 2);
    
    let ornamentType = 'structural';
    if(duration < spb * 0.75){
      ornamentType = 'passing';
    } else if(duration < structuralThreshold){
      ornamentType = 'ornament';
    }
    
    return {...ev, ornamentType};
  });
}

function quantizeToGrid(tl, bpm){
  const spb = 60 / Math.max(60, bpm || 120);
  const quant = parseInt(document.getElementById('quant').value || '4', 10);
  const gridSize = spb / quant;
  
  return tl.map((ev, i) => {
    const quantized = Math.round(ev.t / gridSize) * gridSize;
    const nextEv = tl[i+1];
    const duration = nextEv ? (nextEv.t - ev.t) : spb;
    const beats = Math.max(1, Math.round(duration / spb));
    
    return {...ev, t: quantized, beats};
  });
}

function removeRedundantChords(tl, bpm){
  const spb = 60 / Math.max(60, bpm || 120);
  const barDuration = spb * 4;
  
  const out = [];
  let lastLabel = null;
  let lastBar = -1;
  
  for(const ev of tl){
    const currentBar = Math.floor(ev.t / barDuration);
    
    if(!lastLabel || ev.label !== lastLabel){
      out.push(ev);
      lastLabel = ev.label;
      lastBar = currentBar;
      continue;
    }
    
    if(currentBar > lastBar){
      out.push(ev);
      lastBar = currentBar;
    }
  }
  
  return out;
}

function getHarmonicFunction(label, key){
  const rootPc = parseRoot(label); 
  if(rootPc<0) return '—';
  const rel = toPc(rootPc - key.root);
  const scale = key.minor? MINOR_SCALE : MAJOR_SCALE;
  let bestDeg = null, bestDist=999;
  for(let d=0; d<scale.length; d++){
    const dist = Math.min((rel-scale[d]+12)%12,(scale[d]-rel+12)%12);
    if(dist<bestDist){ bestDist=dist; bestDeg=d; }
  }
  if(bestDeg===null) return '—';
  const funcNames = key.minor ? ['i','ii°','III','iv','v','VI','VII'] : ['I','ii','iii','IV','V','vi','vii°'];
  return funcNames[bestDeg] || '—';
}

function hookPlaybackLive(){
  const st=window.__STATE; 
  if(!st) return;
  const capo=parseInt(capoEl.value||'0',10);
  gateChip.style.display='inline-flex';
  
  const words = [];
  for(const seg of WHISPER_SEGMENTS) {
    if(!seg.text || !seg.text.trim()) continue;
    const segWords = seg.text.trim().split(/\s+/);
    const wordDuration = (seg.end - seg.start) / Math.max(1, segWords.length);
    segWords.forEach((word, i) => {
      words.push({
        text: word,
        time: seg.start + (i * wordDuration)
      });
    });
  }
  
  let builtLines = [];
  let currentChordLine = '';
  let currentLyricLine = '';

  player.ontimeupdate=()=>{
    const t=player.currentTime;
    if(t < st.gateTime + 0.3){ 
      liveChordEl.textContent='—'; 
      liveFunctionEl.textContent='—';
      liveLyricEl.textContent='—';
      return; 
    }
    if(gateChip.style.display!=='none') gateChip.style.display='none';

    let i=st.timeline.findIndex(x=>x.t>t);
    if(i===-1) i=st.timeline.length;
    const ev=st.timeline[i-1]||st.timeline[0];
    if(!ev) return;
    
    const shown = sanitizeLabel(applyCapoToLabel(ev.label, capo));
    liveChordEl.textContent = shown;
    liveFunctionEl.textContent = getHarmonicFunction(ev.label, st.key);
    
    const currentWord = words.find(w => t >= w.time && t < w.time + 0.5);
    if(currentWord) {
      liveLyricEl.textContent = currentWord.text;
    } else {
      liveLyricEl.textContent = '—';
    }
    
    if(ev.ornamentType === 'structural'){
      structuralChip.style.display='inline-flex';
      ornamentChip.style.display='none';
    } else {
      structuralChip.style.display='none';
      ornamentChip.style.display='inline-flex';
    }
    
    if(shown !== window.__lastLiveChord) {
      if(currentLyricLine.length > 50) {
        builtLines.push(currentChordLine.trimEnd());
        builtLines.push(currentLyricLine.trimEnd());
        builtLines.push('');
        currentChordLine = '';
        currentLyricLine = '';
      }
      
      while(currentChordLine.length < currentLyricLine.length) {
        currentChordLine += ' ';
      }
      currentChordLine += shown + ' ';
      window.__lastLiveChord = shown;
    }
    
    if(currentWord && currentWord.text !== window.__lastLiveWord) {
      currentLyricLine += currentWord.text + ' ';
      window.__lastLiveWord = currentWord.text;
    }
    
    const display = [...builtLines, currentChordLine, currentLyricLine].filter(l => l.trim()).join('\n');
    liveSheetEl.textContent = display || '—';
  };

  resetSheetBtn.onclick=()=>{ 
    builtLines = [];
    currentChordLine = '';
    currentLyricLine = '';
    window.__lastLiveChord = null;
    window.__lastLiveWord = null;
    liveSheetEl.textContent='—'; 
  };
}

copyBtn.onclick = () => {
  const text = fullSheetEl.textContent;
  navigator.clipboard.writeText(text).then(() => {
    copyBtn.textContent = '✅ הועתק!';
    setTimeout(() => copyBtn.textContent = '📋 העתק דף', 2000);
  });
};

exportBtn.onclick=()=>{
  const st=window.__STATE; 
  if(!st){ alert('אין נתונים'); return; }
  const text = fullSheetEl.textContent;
  const blob = new Blob([text], {type:'text/plain;charset=utf-8'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); 
  a.href = url; 
  a.download = 'chords.txt'; 
  a.click(); 
  URL.revokeObjectURL(url);
};

function detectStartGate(feats){
  const {frameE, bassPc} = feats;
  const energies = [...frameE].filter(x => Number.isFinite(x)).sort((a,b)=>a-b);
  const median = energies[Math.floor(energies.length * 0.5)] || 0;
  const energyThreshold = median * 0.8;
  
  for(let i = 0; i < frameE.length; i++){
    if(frameE[i] < energyThreshold) continue;
    const hasBass = bassPc[i] >= 0;
    if(hasBass) return Math.max(0, i - 1);
  }
  
  return 0;
}

function mixStereo(buf){ 
  const a=buf.getChannelData(0), b=buf.getChannelData(1)||a; 
  const m=new Float32Array(buf.length); 
  for(let i=0;i<buf.length;i++) m[i]=(a[i]+b[i])*0.5; 
  return m; 
}

function resampleLinear(x,sr,target){ 
  const r=target/sr, L=Math.floor(x.length*r), y=new Float32Array(L); 
  for(let i=0;i<L;i++){ 
    const t=i/r, i0=Math.floor(t), i1=Math.min(x.length-1,i0+1); 
    y[i]=x[i0]*(1-(t-i0))+x[i1]*(t-i0); 
  } 
  return y; 
}

function percentileLocal(arr, p){ 
  const a=[...arr].filter(x=>Number.isFinite(x)).sort((x,y)=>x-y); 
  return a[Math.floor((p/100)*(a.length-1))] || 0; 
}

function refreshSheetTabView(){
  const st = window.__STATE;
  if(!st){
    if(fullSheetEl) fullSheetEl.textContent='לחץ "נתח"';
    return;
  }
  
  const capo = parseInt(capoEl.value||'0',10);
  
  const hasWhisperTimestamps = WHISPER_SEGMENTS && WHISPER_SEGMENTS.length > 0 && 
                               WHISPER_SEGMENTS.some(s => s.start > 0 || s.end > 0);
  
  if(!hasWhisperTimestamps) {
    console.log('⚠️ No Whisper timestamps - showing chords only');
    
    let output = '🎸 אקורדים:\n\n';
    let line = '';
    
    st.timeline.forEach((ev, i) => {
      const chord = applyCapoToLabel(ev.label, capo);
      line += chord.padEnd(8);
      
      if((i + 1) % 6 === 0) {
        output += line + '\n';
        line = '';
      }
    });
    
    if(line) output += line + '\n';
    
    output += '\n\n💡 לסנכרון מילים צריך Whisper עם timestamps';
    
    fullSheetEl.textContent = output;
    return;
  }
  
  console.log('✅ Building synced sheet - has timestamps!');
  
  const words = [];
  for(const seg of WHISPER_SEGMENTS) {
    if(!seg.text || !seg.text.trim()) continue;
    
    const segWords = seg.text.trim().split(/\s+/);
    const wordDuration = (seg.end - seg.start) / Math.max(1, segWords.length);
    
    segWords.forEach((word, i) => {
      words.push({
        text: word,
        time: seg.start + (i * wordDuration)
      });
    });
  }
  
  if(words.length === 0) {
    fullSheetEl.textContent = 'אין מילים זמינות';
    return;
  }
  
  const all = [];
  st.timeline.forEach(ch => all.push({ 
    type: 'chord', 
    time: ch.t, 
    text: applyCapoToLabel(ch.label, capo) 
  }));
  words.forEach(w => all.push({ 
    type: 'word', 
    time: w.time, 
    text: w.text 
  }));
  all.sort((a, b) => a.time - b.time);
  
  let output = '';
  let chordLine = '';
  let lyricLine = '';
  
  for(const item of all) {
    if(item.type === 'chord') {
      while(chordLine.length < lyricLine.length) chordLine += ' ';
      chordLine += item.text + ' ';
    } else {
      lyricLine += item.text + ' ';
      
      if(lyricLine.length > 60) {
        output += chordLine + '\n' + lyricLine + '\n\n';
        chordLine = '';
        lyricLine = '';
      }
    }
  }
  
  if(lyricLine || chordLine) {
    output += chordLine + '\n' + lyricLine + '\n';
  }
  
  fullSheetEl.textContent = output;
}

console.log('✅ ChordFinder v20 - Perfect Sync - FIXED: Whisper after audio download!');
</script>
</body>
</html>
